// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/arithmetic.isle
// - src/opts/bitops.isle
// - src/opts/cprop.isle
// - src/opts/extends.isle
// - src/opts/icmp.isle
// - src/opts/remat.isle
// - src/opts/selects.isle
// - src/opts/shifts.isle
// - /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u128_as_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_as_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_as_i32(&mut self, arg0: u64) -> i32;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn u32_to_offset32(&mut self, arg0: u32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn splat64(&mut self, arg0: u64) -> Constant;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term eq.
pub fn constructor_eq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg1, arg2);
    // Rule at src/prelude_opt.isle line 20.
    return v4;
}

// Generated as internal constructor for term ne.
pub fn constructor_ne<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 21.
    return v4;
}

// Generated as internal constructor for term ult.
pub fn constructor_ult<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 22.
    return v4;
}

// Generated as internal constructor for term ule.
pub fn constructor_ule<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 23.
    return v4;
}

// Generated as internal constructor for term ugt.
pub fn constructor_ugt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 24.
    return v4;
}

// Generated as internal constructor for term uge.
pub fn constructor_uge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 25.
    return v4;
}

// Generated as internal constructor for term slt.
pub fn constructor_slt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 26.
    return v4;
}

// Generated as internal constructor for term sle.
pub fn constructor_sle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 27.
    return v4;
}

// Generated as internal constructor for term sgt.
pub fn constructor_sgt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 28.
    return v4;
}

// Generated as internal constructor for term sge.
pub fn constructor_sge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 29.
    return v4;
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v5,
                args: ref v6,
            } => {
                match v5 {
                    &Opcode::Iadd => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v252 = constructor_iadd(ctx, v2.0, v125.1, v7.1);
                                                                                let v253 = constructor_iadd(ctx, v2.0, v125.0, v252);
                                                                                // Rule at src/opts/cprop.isle line 122.
                                                                                returns.push(v253);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v265 = C::u64_sub(ctx, v16, v141);
                                                                                let v266 = C::imm64_masked(ctx, v2.0, v265);
                                                                                let v267 = constructor_iconst(ctx, v2.0, v266);
                                                                                let v269 = constructor_iadd(ctx, v2.0, v125.0, v267);
                                                                                // Rule at src/opts/cprop.isle line 144.
                                                                                returns.push(v269);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v258,
                                                                        imm: v259,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v258 {
                                                                            if v2.0 == v157.0 {
                                                                                let v260 = C::u64_from_imm64(ctx, v259);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v270 = C::u64_add(ctx, v260, v16);
                                                                                let v271 = C::imm64_masked(ctx, v2.0, v270);
                                                                                let v272 = constructor_iconst(ctx, v2.0, v271);
                                                                                let v273 = constructor_isub(ctx, v2.0, v272, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 148.
                                                                                returns.push(v273);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            if v2.0 == v11.0 {
                                                                let v55 = constructor_ineg(
                                                                    ctx, v2.0, v37,
                                                                );
                                                                // Rule at src/opts/arithmetic.isle line 71.
                                                                returns.push(v55);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 9.
                                                    returns.push(v25);
                                                }
                                                0x1 => {
                                                    let v10 = C::inst_data_etor(ctx, v7.1);
                                                    let mut v10 = v10;
                                                    while let Some(v11) = v10.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } = &v11.1
                                                        {
                                                            if let &Opcode::Bnot = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v56 = constructor_ineg(
                                                                        ctx, v2.0, v39,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 73.
                                                                    returns.push(v56);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                            let v243 = constructor_iadd(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 91.
                                            returns.push(v243);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v163 =
                                                                    C::u64_add(ctx, v24, v16);
                                                                let v164 =
                                                                    C::imm64_masked(ctx, v45, v163);
                                                                let v165 = constructor_iconst(
                                                                    ctx, v45, v164,
                                                                );
                                                                let v166 = C::subsume(ctx, v165);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v166);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 4.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 5.
                                            returns.push(v17);
                                        }
                                    }
                                    let v396 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 6.
                                    returns.push(v396);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v265 = C::u64_sub(ctx, v16, v141);
                                                                                let v266 = C::imm64_masked(ctx, v2.0, v265);
                                                                                let v267 = constructor_iconst(ctx, v2.0, v266);
                                                                                let v268 = constructor_isub(ctx, v2.0, v125.0, v267);
                                                                                // Rule at src/opts/cprop.isle line 140.
                                                                                returns.push(v268);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v254 = C::u64_add(ctx, v141, v16);
                                                                                let v255 = C::imm64_masked(ctx, v2.0, v254);
                                                                                let v256 = constructor_iconst(ctx, v2.0, v255);
                                                                                let v257 = constructor_isub(ctx, v2.0, v125.0, v256);
                                                                                // Rule at src/opts/cprop.isle line 132.
                                                                                returns.push(v257);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v258,
                                                                        imm: v259,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v258 {
                                                                            if v2.0 == v157.0 {
                                                                                let v260 = C::u64_from_imm64(ctx, v259);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v261 = C::u64_sub(ctx, v260, v16);
                                                                                let v262 = C::imm64_masked(ctx, v2.0, v261);
                                                                                let v263 = constructor_iconst(ctx, v2.0, v262);
                                                                                let v264 = constructor_isub(ctx, v2.0, v263, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 136.
                                                                                returns.push(v264);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v52 =
                                                            C::i64_sextend_imm64(ctx, v2.0, v15);
                                                        if v52 == -0x1 {
                                                            if v2.0 == v11.0 {
                                                                let v55 = constructor_ineg(
                                                                    ctx, v2.0, v37,
                                                                );
                                                                // Rule at src/opts/arithmetic.isle line 75.
                                                                returns.push(v55);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 19.
                                                returns.push(v26);
                                            }
                                            let v244 = constructor_isub(ctx, v2.0, v7.1, v7.0);
                                            let v245 = constructor_ineg(ctx, v2.0, v244);
                                            // Rule at src/opts/cprop.isle line 96.
                                            returns.push(v245);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v167 =
                                                                    C::u64_sub(ctx, v24, v16);
                                                                let v168 =
                                                                    C::imm64_masked(ctx, v45, v167);
                                                                let v169 = constructor_iconst(
                                                                    ctx, v45, v168,
                                                                );
                                                                let v170 = C::subsume(ctx, v169);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v170);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 8.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 14.
                                            returns.push(v17);
                                        }
                                    }
                                    let v396 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 10.
                                    returns.push(v396);
                                }
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/arithmetic.isle line 40.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Imul = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v274 = constructor_imul(ctx, v2.0, v125.1, v7.1);
                                                                            let v275 = constructor_imul(ctx, v2.0, v125.0, v274);
                                                                            // Rule at src/opts/cprop.isle line 153.
                                                                            returns.push(v275);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Ineg = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v38,
                                                    arg: v39,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Ineg = v38 {
                                                        if v2.0 == v11.0 {
                                                            let v40 = constructor_imul(
                                                                ctx, v2.0, v37, v39,
                                                            );
                                                            let v41 = C::subsume(ctx, v40);
                                                            // Rule at src/opts/arithmetic.isle line 28.
                                                            returns.push(v41);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/arithmetic.isle line 57.
                                                    returns.push(v17);
                                                }
                                                0x1 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 47.
                                                    returns.push(v25);
                                                }
                                                _ => {}
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 66.
                                                returns.push(v26);
                                            }
                                            let v246 = constructor_imul(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v246);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v171 =
                                                                    C::u64_mul(ctx, v24, v16);
                                                                let v172 =
                                                                    C::imm64_masked(ctx, v45, v171);
                                                                let v173 = constructor_iconst(
                                                                    ctx, v45, v172,
                                                                );
                                                                let v174 = C::subsume(ctx, v173);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v174);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v82 = C::simm32(ctx, v23);
                                        if let Some(v83) = v82 {
                                            if v83 == 0x2 {
                                                let v84 = constructor_iadd(ctx, v2.0, v7.1, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 105.
                                                returns.push(v84);
                                            }
                                        }
                                        let v90 = C::imm64_power_of_two(ctx, v23);
                                        if let Some(v91) = v90 {
                                            let v92 = C::imm64(ctx, v91);
                                            let v93 = constructor_iconst(ctx, v2.0, v92);
                                            let v94 = constructor_ishl(ctx, v2.0, v7.1, v93);
                                            // Rule at src/opts/arithmetic.isle line 114.
                                            returns.push(v94);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    if v2.0 == v11.0 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        match v16 {
                                            0x0 => {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 53.
                                                returns.push(v25);
                                            }
                                            0x1 => {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 43.
                                                returns.push(v17);
                                            }
                                            _ => {}
                                        }
                                        let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                        if v52 == -0x1 {
                                            let v53 = constructor_ineg(ctx, v2.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 63.
                                            returns.push(v53);
                                        }
                                    }
                                    let v79 = C::simm32(ctx, v15);
                                    if let Some(v80) = v79 {
                                        if v80 == 0x2 {
                                            let v81 = constructor_iadd(ctx, v2.0, v7.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 103.
                                            returns.push(v81);
                                        }
                                    }
                                    let v85 = C::imm64_power_of_two(ctx, v15);
                                    if let Some(v86) = v85 {
                                        let v87 = C::imm64(ctx, v86);
                                        let v88 = constructor_iconst(ctx, v2.0, v87);
                                        let v89 = constructor_ishl(ctx, v2.0, v7.0, v88);
                                        // Rule at src/opts/arithmetic.isle line 112.
                                        returns.push(v89);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 94.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v180 = C::u64_udiv(ctx, v24, v16);
                                                        if let Some(v181) = v180 {
                                                            if v11.0 == v19.0 {
                                                                let v182 =
                                                                    C::imm64_masked(ctx, v45, v181);
                                                                let v183 = constructor_iconst(
                                                                    ctx, v45, v182,
                                                                );
                                                                let v184 = C::subsume(ctx, v183);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v184);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 90.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v175 = C::u64_sdiv(ctx, v24, v16);
                                                        if let Some(v176) = v175 {
                                                            if v11.0 == v19.0 {
                                                                let v177 =
                                                                    C::imm64_masked(ctx, v45, v176);
                                                                let v178 = constructor_iconst(
                                                                    ctx, v45, v177,
                                                                );
                                                                let v179 = C::subsume(ctx, v178);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v179);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Band = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v278 = constructor_band(ctx, v2.0, v125.1, v7.1);
                                                                            let v279 = constructor_band(ctx, v2.0, v125.0, v278);
                                                                            // Rule at src/opts/cprop.isle line 159.
                                                                            returns.push(v279);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v357,
                                    args: ref v358,
                                    cond: ref v359,
                                } => {
                                    if let &Opcode::Icmp = v357 {
                                        let v10 = C::inst_data_etor(ctx, v7.1);
                                        let mut v10 = v10;
                                        while let Some(v11) = v10.next(ctx) {
                                            match &v11.1 {
                                                &InstructionData::IntCompare {
                                                    opcode: ref v382,
                                                    args: ref v383,
                                                    cond: ref v384,
                                                } => {
                                                    if let &Opcode::Icmp = v382 {
                                                        let v388 = constructor_intcc_comparable(
                                                            ctx, v359, v384,
                                                        );
                                                        if let Some(v389) = v388 {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v360 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v358,
                                                                        );
                                                                    let v385 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v383,
                                                                        );
                                                                    if v360.0 == v385.0 {
                                                                        if v360.1 == v385.1 {
                                                                            let v390 = constructor_decompose_intcc(ctx, v359);
                                                                            let v391 = constructor_decompose_intcc(ctx, v384);
                                                                            let v392 = C::u64_and(
                                                                                ctx, v390, v391,
                                                                            );
                                                                            let v393 = constructor_compose_icmp(ctx, v2.0, v392, v389, v360.0, v360.1);
                                                                            // Rule at src/opts/icmp.isle line 128.
                                                                            returns.push(v393);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } => {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v355 = C::ty_int(ctx, v2.0);
                                                            if let Some(v356) = v355 {
                                                                // Rule at src/opts/icmp.isle line 39.
                                                                returns.push(v7.0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Bnot => {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v7.1 == v37 {
                                                        if v19.0 == v47 {
                                                            let v49 = C::imm64(ctx, 0x0);
                                                            let v50 =
                                                                constructor_iconst(ctx, v47, v49);
                                                            let v51 = C::subsume(ctx, v50);
                                                            // Rule at src/opts/bitops.isle line 50.
                                                            returns.push(v51);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v355 = C::ty_int(ctx, v2.0);
                                                            if let Some(v356) = v355 {
                                                                let v363 =
                                                                    C::inst_data_etor(ctx, v37);
                                                                let mut v363 = v363;
                                                                while let Some(v364) =
                                                                    v363.next(ctx)
                                                                {
                                                                    if let &InstructionData::IntCompare {
                                                                        opcode: ref v367,
                                                                        args: ref v368,
                                                                        cond: ref v369,
                                                                    } = &v364.1 {
                                                                        if let &Opcode::Icmp = v367 {
                                                                            // Rule at src/opts/icmp.isle line 44.
                                                                            returns.push(v7.0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        let v315 = C::value_type(ctx, v37);
                                                        let v316 = C::ty_mask(ctx, v315);
                                                        let v317 = C::u64_and(ctx, v16, v316);
                                                        let v318 = C::u64_eq(ctx, v316, v317);
                                                        if v318 == true {
                                                            // Rule at src/opts/extends.isle line 9.
                                                            returns.push(v7.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v315 = C::value_type(ctx, v37);
                                                        let v316 = C::ty_mask(ctx, v315);
                                                        let v319 = C::u64_eq(ctx, v16, v316);
                                                        if v319 == true {
                                                            let v320 =
                                                                constructor_uextend(ctx, v2.0, v37);
                                                            // Rule at src/opts/extends.isle line 15.
                                                            returns.push(v320);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 48.
                                                returns.push(v17);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 42.
                                                returns.push(v25);
                                            }
                                            let v248 = constructor_band(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v248);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v189 =
                                                                    C::u64_and(ctx, v24, v16);
                                                                let v190 =
                                                                    C::imm64_masked(ctx, v45, v189);
                                                                let v191 = constructor_iconst(
                                                                    ctx, v45, v190,
                                                                );
                                                                let v192 = C::subsume(ctx, v191);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v192);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 12.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v49 = C::imm64(ctx, 0x0);
                                                        let v50 = constructor_iconst(ctx, v47, v49);
                                                        let v51 = C::subsume(ctx, v50);
                                                        // Rule at src/opts/bitops.isle line 49.
                                                        returns.push(v51);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 47.
                                                returns.push(v25);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 39.
                                                returns.push(v17);
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 14.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 38.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    match &v11.1 {
                                                        &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } => {
                                                            if let &Opcode::Bnot = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    if v39 == v125.1 {
                                                                        let v128 = constructor_bor(
                                                                            ctx, v2.0, v125.0, v7.1,
                                                                        );
                                                                        // Rule at src/opts/bitops.isle line 64.
                                                                        returns.push(v128);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v14,
                                                            imm: v15,
                                                        } => {
                                                            if let &Opcode::Iconst = v14 {
                                                                if v2.0 == v11.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v139,
                                                                            imm: v140,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Iconst = v139 {
                                                                                let v142 = C::ty_mask(ctx, v2.0);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v143 = C::u64_and(ctx, v142, v16);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v144 = C::u64_not(ctx, v141);
                                                                                let v145 = C::u64_and(ctx, v142, v144);
                                                                                let v146 = C::u64_eq(ctx, v143, v145);
                                                                                if v146 == true {
                                                                                    if v2.0 == v136.0 {
                                                                                        let v128 = constructor_bor(ctx, v2.0, v125.0, v7.1);
                                                                                        // Rule at src/opts/bitops.isle line 84.
                                                                                        returns.push(v128);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v276 = constructor_bor(ctx, v2.0, v125.1, v7.1);
                                                                                let v277 = constructor_bor(ctx, v2.0, v125.0, v276);
                                                                                // Rule at src/opts/cprop.isle line 156.
                                                                                returns.push(v277);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v357,
                                    args: ref v358,
                                    cond: ref v359,
                                } => {
                                    if let &Opcode::Icmp = v357 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::IntCompare {
                                                    opcode: ref v382,
                                                    args: ref v383,
                                                    cond: ref v384,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Icmp = v382 {
                                                        let v388 = constructor_intcc_comparable(
                                                            ctx, v359, v384,
                                                        );
                                                        if let Some(v389) = v388 {
                                                            if v2.0 == v11.0 {
                                                                let v360 = C::unpack_value_array_2(
                                                                    ctx, v358,
                                                                );
                                                                let v385 = C::unpack_value_array_2(
                                                                    ctx, v383,
                                                                );
                                                                if v360.0 == v385.0 {
                                                                    if v360.1 == v385.1 {
                                                                        let v390 = constructor_decompose_intcc(ctx, v359);
                                                                        let v391 = constructor_decompose_intcc(ctx, v384);
                                                                        let v394 = C::u64_or(
                                                                            ctx, v390, v391,
                                                                        );
                                                                        let v395 = constructor_compose_icmp(ctx, v2.0, v394, v389, v360.0, v360.1);
                                                                        // Rule at src/opts/icmp.isle line 132.
                                                                        returns.push(v395);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v46 = C::ty_int(ctx, v45);
                                            if let Some(v47) = v46 {
                                                if v7.1 == v37 {
                                                    if v19.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 35.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v129,
                                                    args: ref v130,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Band = v129 {
                                                        if v2.0 == v11.0 {
                                                            let v131 =
                                                                C::unpack_value_array_2(ctx, v130);
                                                            if v37 == v131.1 {
                                                                let v134 = constructor_bor(
                                                                    ctx, v2.0, v131.0, v7.0,
                                                                );
                                                                // Rule at src/opts/bitops.isle line 73.
                                                                returns.push(v134);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 8.
                                                returns.push(v25);
                                            }
                                            let v247 = constructor_bor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 103.
                                            returns.push(v247);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v185 = C::u64_or(ctx, v24, v16);
                                                                let v186 =
                                                                    C::imm64_masked(ctx, v45, v185);
                                                                let v187 = constructor_iconst(
                                                                    ctx, v45, v186,
                                                                );
                                                                let v188 = C::subsume(ctx, v187);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v188);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 16.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 34.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 4.
                                                returns.push(v17);
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 18.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 12.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bxor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v46 = C::ty_int(ctx, v45);
                                            if let Some(v47) = v46 {
                                                if v7.0 == v39 {
                                                    if v11.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 32.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 16.
                                                returns.push(v17);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v147 = constructor_bnot(ctx, v2.0, v7.0);
                                                // Rule at src/opts/bitops.isle line 92.
                                                returns.push(v147);
                                            }
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Bxor = v123 {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v280 = constructor_bxor(ctx, v2.0, v125.1, v7.1);
                                                                            let v281 = constructor_bxor(ctx, v2.0, v125.0, v280);
                                                                            // Rule at src/opts/cprop.isle line 162.
                                                                            returns.push(v281);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v11.0 == v45 {
                                                let v18 = C::inst_data_etor(ctx, v7.0);
                                                let mut v18 = v18;
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v22,
                                                        imm: v23,
                                                    } = &v19.1
                                                    {
                                                        if let &Opcode::Iconst = v22 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v193 =
                                                                    C::u64_xor(ctx, v24, v16);
                                                                let v194 =
                                                                    C::imm64_masked(ctx, v45, v193);
                                                                let v195 = constructor_iconst(
                                                                    ctx, v45, v194,
                                                                );
                                                                let v196 = C::subsume(ctx, v195);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v196);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 22.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v7.1 == v37 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v19.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 33.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 20.
                                                returns.push(v25);
                                            }
                                            let v249 = constructor_bxor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v249);
                                        }
                                        let v396 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 20.
                                        returns.push(v396);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/bitops.isle line 26.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 20.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 16.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } => {
                                                    match v123 {
                                                        &Opcode::Ushr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v426 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v427 = C::imm64_shl(ctx, v45, v426, v140);
                                                                                let v428 = constructor_iconst(ctx, v45, v427);
                                                                                let v429 = constructor_band(ctx, v45, v125.0, v428);
                                                                                // Rule at src/opts/shifts.isle line 27.
                                                                                returns.push(v429);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v426 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v427 = C::imm64_shl(ctx, v45, v426, v140);
                                                                                let v428 = constructor_iconst(ctx, v45, v427);
                                                                                let v429 = constructor_band(ctx, v45, v125.0, v428);
                                                                                // Rule at src/opts/shifts.isle line 32.
                                                                                returns.push(v429);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        if v19.0 == v45 {
                                                            let v204 =
                                                                C::imm64_shl(ctx, v45, v23, v15);
                                                            let v205 =
                                                                constructor_iconst(ctx, v45, v204);
                                                            let v206 = C::subsume(ctx, v205);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v206);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 4.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                if let &Opcode::Ishl = v123 {
                                                    let v125 = C::unpack_value_array_2(ctx, v124);
                                                    let v135 = C::inst_data_etor(ctx, v125.1);
                                                    let mut v135 = v135;
                                                    while let Some(v136) = v135.next(ctx) {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref v139,
                                                            imm: v140,
                                                        } = &v136.1
                                                        {
                                                            if let &Opcode::Iconst = v139 {
                                                                if v15 == v140 {
                                                                    let v44 =
                                                                        C::fits_in_64(ctx, v2.0);
                                                                    if let Some(v45) = v44 {
                                                                        let v46 =
                                                                            C::ty_int(ctx, v45);
                                                                        if let Some(v47) = v46 {
                                                                            if v19.0 == v47 {
                                                                                let v115 =
                                                                                    C::ty_mask(
                                                                                        ctx, v47,
                                                                                    );
                                                                                let v116 = C::imm64(
                                                                                    ctx, v115,
                                                                                );
                                                                                let v430 =
                                                                                    C::imm64_ushr(
                                                                                        ctx, v47,
                                                                                        v116, v140,
                                                                                    );
                                                                                let v431 = constructor_iconst(ctx, v47, v430);
                                                                                let v432 = constructor_band(ctx, v47, v125.0, v431);
                                                                                // Rule at src/opts/shifts.isle line 41.
                                                                                returns.push(v432);
                                                                            }
                                                                        }
                                                                    }
                                                                    let v141 = C::u64_from_imm64(
                                                                        ctx, v140,
                                                                    );
                                                                    let v441 =
                                                                        C::u64_is_zero(ctx, v141);
                                                                    if v441 == false {
                                                                        let v150 =
                                                                            C::ty_bits(ctx, v2.0);
                                                                        let v151 =
                                                                            C::u8_as_u64(ctx, v150);
                                                                        let v442 = C::u64_sub(
                                                                            ctx, v151, v141,
                                                                        );
                                                                        let v443 = constructor_shift_amt_to_type(ctx, v442);
                                                                        if let Some(v444) = v443 {
                                                                            if v2.0 == v19.0 {
                                                                                let v445 = constructor_ireduce(ctx, v444, v125.0);
                                                                                let v447 = constructor_uextend(ctx, v2.0, v445);
                                                                                // Rule at src/opts/shifts.isle line 91.
                                                                                returns.push(v447);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v207 =
                                                                C::imm64_ushr(ctx, v45, v23, v15);
                                                            let v208 =
                                                                constructor_iconst(ctx, v45, v207);
                                                            let v209 = C::subsume(ctx, v208);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v209);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 8.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                match v123 {
                                                    &Opcode::Bor => {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v154 = C::u64_eq(ctx, v16, v153);
                                                        if v154 == true {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v148,
                                                                            arg: v149,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Ineg = v148 {
                                                                                if v2.0 == v136.0 {
                                                                                    if v125.0 == v149 {
                                                                                        let v155 = constructor_bmask(ctx, v2.0, v125.0);
                                                                                        // Rule at src/opts/bitops.isle line 100.
                                                                                        returns.push(v155);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    let v156 = C::inst_data_etor(
                                                                        ctx, v125.0,
                                                                    );
                                                                    let mut v156 = v156;
                                                                    while let Some(v157) =
                                                                        v156.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v160,
                                                                            arg: v161,
                                                                        } = &v157.1 {
                                                                            if let &Opcode::Ineg = v160 {
                                                                                if v125.1 == v161 {
                                                                                    if v2.0 == v157.0 {
                                                                                        let v162 = constructor_bmask(ctx, v2.0, v161);
                                                                                        // Rule at src/opts/bitops.isle line 104.
                                                                                        returns.push(v162);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &Opcode::Ishl => {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v15 == v140 {
                                                                            let v156 = C::inst_data_etor(ctx, v125.0);
                                                                            let mut v156 = v156;
                                                                            while let Some(v157) = v156.next(ctx) {
                                                                                if let &InstructionData::Unary {
                                                                                    opcode: ref v160,
                                                                                    arg: v161,
                                                                                } = &v157.1 {
                                                                                    match v160 {
                                                                                        &Opcode::Uextend => {
                                                                                            if v2.0 == v157.0 {
                                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                                let v434 = C::ty_bits_u64(ctx, v2.0);
                                                                                                let v433 = C::value_type(ctx, v161);
                                                                                                let v435 = C::ty_bits_u64(ctx, v433);
                                                                                                let v436 = C::u64_sub(ctx, v434, v435);
                                                                                                let v437 = C::u64_eq(ctx, v141, v436);
                                                                                                if v437 == true {
                                                                                                    let v438 = constructor_sextend(ctx, v2.0, v161);
                                                                                                    // Rule at src/opts/shifts.isle line 50.
                                                                                                    returns.push(v438);
                                                                                                }
                                                                                                let v439 = C::u64_lt(ctx, v141, v436);
                                                                                                if v439 == true {
                                                                                                    // Rule at src/opts/shifts.isle line 62.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        &Opcode::Sextend => {
                                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                                            let v434 = C::ty_bits_u64(ctx, v2.0);
                                                                                            let v433 = C::value_type(ctx, v161);
                                                                                            let v435 = C::ty_bits_u64(ctx, v433);
                                                                                            let v436 = C::u64_sub(ctx, v434, v435);
                                                                                            let v440 = C::u64_le(ctx, v141, v436);
                                                                                            if v440 == true {
                                                                                                if v2.0 == v157.0 {
                                                                                                    // Rule at src/opts/shifts.isle line 73.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                            let v441 = C::u64_is_zero(ctx, v141);
                                                                            if v441 == false {
                                                                                let v150 = C::ty_bits(ctx, v2.0);
                                                                                let v151 = C::u8_as_u64(ctx, v150);
                                                                                let v442 = C::u64_sub(ctx, v151, v141);
                                                                                let v443 = constructor_shift_amt_to_type(ctx, v442);
                                                                                if let Some(v444) = v443 {
                                                                                    let v445 = constructor_ireduce(ctx, v444, v125.0);
                                                                                    let v446 = constructor_sextend(ctx, v2.0, v445);
                                                                                    // Rule at src/opts/shifts.isle line 87.
                                                                                    returns.push(v446);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v210 =
                                                                C::imm64_sshr(ctx, v45, v23, v15);
                                                            let v211 =
                                                                constructor_iconst(ctx, v45, v210);
                                                            let v212 = C::subsume(ctx, v211);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v212);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 12.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fmul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Fneg = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Fneg = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v114 =
                                                            constructor_fmul(ctx, v2.0, v37, v39);
                                                        // Rule at src/opts/arithmetic.isle line 127.
                                                        returns.push(v114);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v222,
                args: ref v223,
                cond: ref v224,
            } => {
                if let &Opcode::Icmp = v222 {
                    match v224 {
                        &IntCC::Equal => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    if v225.0 == v225.1 {
                                        let v326 = C::imm64(ctx, 0x1);
                                        let v329 = constructor_iconst(ctx, v47, v326);
                                        // Rule at src/opts/icmp.isle line 5.
                                        returns.push(v329);
                                    }
                                }
                            }
                            let v225 = C::unpack_value_array_2(ctx, v223);
                            let v228 = C::inst_data_etor(ctx, v225.0);
                            let mut v228 = v228;
                            while let Some(v229) = v228.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v321,
                                    arg: v322,
                                } = &v229.1
                                {
                                    if let &Opcode::Uextend = v321 {
                                        let v234 = C::inst_data_etor(ctx, v225.1);
                                        let mut v234 = v234;
                                        while let Some(v235) = v234.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v238,
                                                imm: v239,
                                            } = &v235.1
                                            {
                                                if let &Opcode::Iconst = v238 {
                                                    let v324 = C::u64_from_imm64(ctx, v239);
                                                    if v324 == 0x0 {
                                                        let v330 = C::inst_data_etor(ctx, v322);
                                                        let mut v330 = v330;
                                                        while let Some(v331) = v330.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v334,
                                                                args: ref v335,
                                                                cond: ref v336,
                                                            } = &v331.1
                                                            {
                                                                if let &Opcode::Icmp = v334 {
                                                                    if v2.0 == v331.0 {
                                                                        let v341 =
                                                                            &C::intcc_inverse(
                                                                                ctx, v336,
                                                                            );
                                                                        let v337 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v335,
                                                                            );
                                                                        let v342 = constructor_icmp(
                                                                            ctx, v2.0, v341,
                                                                            v337.0, v337.1,
                                                                        );
                                                                        let v343 =
                                                                            C::subsume(ctx, v342);
                                                                        // Rule at src/opts/icmp.isle line 22.
                                                                        returns.push(v343);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    if v225.0 == v225.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 6.
                                        returns.push(v50);
                                    }
                                }
                            }
                            let v225 = C::unpack_value_array_2(ctx, v223);
                            let v228 = C::inst_data_etor(ctx, v225.0);
                            let mut v228 = v228;
                            while let Some(v229) = v228.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v321,
                                    arg: v322,
                                } = &v229.1
                                {
                                    if let &Opcode::Uextend = v321 {
                                        let v234 = C::inst_data_etor(ctx, v225.1);
                                        let mut v234 = v234;
                                        while let Some(v235) = v234.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v238,
                                                imm: v239,
                                            } = &v235.1
                                            {
                                                if let &Opcode::Iconst = v238 {
                                                    let v324 = C::u64_from_imm64(ctx, v239);
                                                    if v324 == 0x0 {
                                                        let v330 = C::inst_data_etor(ctx, v322);
                                                        let mut v330 = v330;
                                                        while let Some(v331) = v330.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v334,
                                                                args: ref v335,
                                                                cond: ref v336,
                                                            } = &v331.1
                                                            {
                                                                if let &Opcode::Icmp = v334 {
                                                                    if v2.0 == v331.0 {
                                                                        let v340 =
                                                                            C::subsume(ctx, v322);
                                                                        // Rule at src/opts/icmp.isle line 17.
                                                                        returns.push(v340);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                let v378 = C::ty_smin(ctx, v235.0);
                                                let v379 = C::u64_eq(ctx, v324, v378);
                                                if v379 == true {
                                                    let v374 =
                                                        constructor_ne(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 98.
                                                    returns.push(v374);
                                                }
                                                let v380 = C::ty_smax(ctx, v235.0);
                                                let v381 = C::u64_eq(ctx, v324, v380);
                                                if v381 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 118.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 9.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                let v378 = C::ty_smin(ctx, v235.0);
                                                let v379 = C::u64_eq(ctx, v324, v378);
                                                if v379 == true {
                                                    let v326 = C::imm64(ctx, 0x1);
                                                    let v329 = constructor_iconst(ctx, v47, v326);
                                                    let v375 = C::subsume(ctx, v329);
                                                    // Rule at src/opts/icmp.isle line 103.
                                                    returns.push(v375);
                                                }
                                                let v380 = C::ty_smax(ctx, v235.0);
                                                let v381 = C::u64_eq(ctx, v324, v380);
                                                if v381 == true {
                                                    let v373 =
                                                        constructor_eq(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 123.
                                                    returns.push(v373);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v326 = C::imm64(ctx, 0x1);
                                        let v329 = constructor_iconst(ctx, v47, v326);
                                        // Rule at src/opts/icmp.isle line 10.
                                        returns.push(v329);
                                    }
                                }
                            }
                            let v225 = C::unpack_value_array_2(ctx, v223);
                            let v228 = C::inst_data_etor(ctx, v225.0);
                            let mut v228 = v228;
                            while let Some(v229) = v228.next(ctx) {
                                if v229.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v321,
                                        arg: v322,
                                    } = &v229.1
                                    {
                                        if let &Opcode::Uextend = v321 {
                                            let v323 = C::value_type(ctx, v322);
                                            if v323 == I32 {
                                                let v234 = C::inst_data_etor(ctx, v225.1);
                                                let mut v234 = v234;
                                                while let Some(v235) = v234.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v238,
                                                        imm: v239,
                                                    } = &v235.1
                                                    {
                                                        if let &Opcode::Iconst = v238 {
                                                            let v324 = C::u64_from_imm64(ctx, v239);
                                                            if v324 == 0x0 {
                                                                let v326 = C::imm64(ctx, 0x1);
                                                                let v327 = constructor_iconst(
                                                                    ctx, v2.0, v326,
                                                                );
                                                                // Rule at src/opts/extends.isle line 25.
                                                                returns.push(v327);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                let v378 = C::ty_smin(ctx, v235.0);
                                                let v379 = C::u64_eq(ctx, v324, v378);
                                                if v379 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 88.
                                                    returns.push(v51);
                                                }
                                                let v380 = C::ty_smax(ctx, v235.0);
                                                let v381 = C::u64_eq(ctx, v324, v380);
                                                if v381 == true {
                                                    let v374 =
                                                        constructor_ne(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 108.
                                                    returns.push(v374);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 13.
                                        returns.push(v50);
                                    }
                                }
                            }
                            let v225 = C::unpack_value_array_2(ctx, v223);
                            let v228 = C::inst_data_etor(ctx, v225.0);
                            let mut v228 = v228;
                            while let Some(v229) = v228.next(ctx) {
                                if v229.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v321,
                                        arg: v322,
                                    } = &v229.1
                                    {
                                        if let &Opcode::Uextend = v321 {
                                            let v323 = C::value_type(ctx, v322);
                                            if v323 == I32 {
                                                let v234 = C::inst_data_etor(ctx, v225.1);
                                                let mut v234 = v234;
                                                while let Some(v235) = v234.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v238,
                                                        imm: v239,
                                                    } = &v235.1
                                                    {
                                                        if let &Opcode::Iconst = v238 {
                                                            let v324 = C::u64_from_imm64(ctx, v239);
                                                            if v324 == 0x0 {
                                                                let v49 = C::imm64(ctx, 0x0);
                                                                let v325 = constructor_iconst(
                                                                    ctx, v2.0, v49,
                                                                );
                                                                // Rule at src/opts/extends.isle line 20.
                                                                returns.push(v325);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                let v378 = C::ty_smin(ctx, v235.0);
                                                let v379 = C::u64_eq(ctx, v324, v378);
                                                if v379 == true {
                                                    let v373 =
                                                        constructor_eq(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 93.
                                                    returns.push(v373);
                                                }
                                                let v380 = C::ty_smax(ctx, v235.0);
                                                let v381 = C::u64_eq(ctx, v324, v380);
                                                if v381 == true {
                                                    let v326 = C::imm64(ctx, 0x1);
                                                    let v329 = constructor_iconst(ctx, v47, v326);
                                                    let v375 = C::subsume(ctx, v329);
                                                    // Rule at src/opts/icmp.isle line 113.
                                                    returns.push(v375);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v326 = C::imm64(ctx, 0x1);
                                        let v329 = constructor_iconst(ctx, v47, v326);
                                        // Rule at src/opts/icmp.isle line 14.
                                        returns.push(v329);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                if v324 == 0x0 {
                                                    let v374 =
                                                        constructor_ne(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 60.
                                                    returns.push(v374);
                                                }
                                                let v376 = C::ty_umax(ctx, v235.0);
                                                let v377 = C::u64_eq(ctx, v324, v376);
                                                if v377 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 78.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 7.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                if v324 == 0x0 {
                                                    let v326 = C::imm64(ctx, 0x1);
                                                    let v329 = constructor_iconst(ctx, v47, v326);
                                                    let v375 = C::subsume(ctx, v329);
                                                    // Rule at src/opts/icmp.isle line 64.
                                                    returns.push(v375);
                                                }
                                                let v376 = C::ty_umax(ctx, v235.0);
                                                let v377 = C::u64_eq(ctx, v324, v376);
                                                if v377 == true {
                                                    let v373 =
                                                        constructor_eq(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 83.
                                                    returns.push(v373);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v326 = C::imm64(ctx, 0x1);
                                        let v329 = constructor_iconst(ctx, v47, v326);
                                        // Rule at src/opts/icmp.isle line 8.
                                        returns.push(v329);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                if v324 == 0x0 {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 52.
                                                    returns.push(v51);
                                                }
                                                let v376 = C::ty_umax(ctx, v235.0);
                                                let v377 = C::u64_eq(ctx, v324, v376);
                                                if v377 == true {
                                                    let v374 =
                                                        constructor_ne(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 68.
                                                    returns.push(v374);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 11.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v225 = C::unpack_value_array_2(ctx, v223);
                                    let v234 = C::inst_data_etor(ctx, v225.1);
                                    let mut v234 = v234;
                                    while let Some(v235) = v234.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v238,
                                            imm: v239,
                                        } = &v235.1
                                        {
                                            if let &Opcode::Iconst = v238 {
                                                let v324 = C::u64_from_imm64(ctx, v239);
                                                if v324 == 0x0 {
                                                    let v373 =
                                                        constructor_eq(ctx, v47, v225.0, v225.1);
                                                    // Rule at src/opts/icmp.isle line 56.
                                                    returns.push(v373);
                                                }
                                                let v376 = C::ty_umax(ctx, v235.0);
                                                let v377 = C::u64_eq(ctx, v324, v376);
                                                if v377 == true {
                                                    let v326 = C::imm64(ctx, 0x1);
                                                    let v329 = constructor_iconst(ctx, v47, v326);
                                                    let v375 = C::subsume(ctx, v329);
                                                    // Rule at src/opts/icmp.isle line 73.
                                                    returns.push(v375);
                                                }
                                            }
                                        }
                                    }
                                    if v225.0 == v225.1 {
                                        let v326 = C::imm64(ctx, 0x1);
                                        let v329 = constructor_iconst(ctx, v47, v326);
                                        // Rule at src/opts/icmp.isle line 12.
                                        returns.push(v329);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v225 = C::unpack_value_array_2(ctx, v223);
                    let v228 = C::inst_data_etor(ctx, v225.0);
                    let mut v228 = v228;
                    while let Some(v229) = v228.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v232,
                            imm: v233,
                        } = &v229.1
                        {
                            if let &Opcode::Iconst = v232 {
                                let v234 = C::inst_data_etor(ctx, v225.1);
                                let mut v234 = v234;
                                while let Some(v235) = v234.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v238,
                                        imm: v239,
                                    } = &v235.1
                                    {
                                        if let &Opcode::Iconst = v238 {
                                            if v229.0 == v235.0 {
                                                let v240 =
                                                    C::imm64_icmp(ctx, v229.0, v224, v233, v239);
                                                let v241 = constructor_iconst(ctx, v2.0, v240);
                                                let v242 = C::subsume(ctx, v241);
                                                // Rule at src/opts/cprop.isle line 79.
                                                returns.push(v242);
                                            }
                                        }
                                    }
                                }
                                let v250 = &C::intcc_reverse(ctx, v224);
                                let v251 = constructor_icmp(ctx, v2.0, v250, v225.1, v225.0);
                                // Rule at src/opts/cprop.isle line 113.
                                returns.push(v251);
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v95,
                args: ref v96,
            } => {
                match v95 {
                    &Opcode::Select => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            match &v102.1 {
                                &InstructionData::FloatCompare {
                                    opcode: ref v417,
                                    args: ref v418,
                                    cond: ref v419,
                                } => {
                                    if let &Opcode::Fcmp = v417 {
                                        match v419 {
                                            &FloatCC::GreaterThan => {
                                                let v420 = C::unpack_value_array_2(ctx, v418);
                                                if v97.1 == v420.0 {
                                                    if v97.2 == v420.1 {
                                                        let v424 = constructor_fmax_pseudo(
                                                            ctx, v2.0, v420.0, v420.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 57.
                                                        returns.push(v424);
                                                    }
                                                }
                                            }
                                            &FloatCC::LessThan => {
                                                let v420 = C::unpack_value_array_2(ctx, v418);
                                                if v97.1 == v420.0 {
                                                    if v97.2 == v420.1 {
                                                        let v423 = constructor_fmin_pseudo(
                                                            ctx, v2.0, v420.0, v420.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 54.
                                                        returns.push(v423);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v403,
                                    args: ref v404,
                                    cond: ref v405,
                                } => {
                                    if let &Opcode::Icmp = v403 {
                                        match v405 {
                                            &IntCC::SignedGreaterThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 8.
                                                        returns.push(v409);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 22.
                                                        returns.push(v411);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 9.
                                                        returns.push(v409);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 23.
                                                        returns.push(v411);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 12.
                                                        returns.push(v411);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 18.
                                                        returns.push(v409);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 13.
                                                        returns.push(v411);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 19.
                                                        returns.push(v409);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 10.
                                                        returns.push(v410);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 24.
                                                        returns.push(v412);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 11.
                                                        returns.push(v410);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 25.
                                                        returns.push(v412);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 14.
                                                        returns.push(v412);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 20.
                                                        returns.push(v410);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 15.
                                                        returns.push(v412);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 21.
                                                        returns.push(v410);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v105,
                                    arg: v106,
                                } => {
                                    if let &Opcode::Uextend = v105 {
                                        let v344 = C::inst_data_etor(ctx, v106);
                                        let mut v344 = v344;
                                        while let Some(v345) = v344.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v348,
                                                args: ref v349,
                                                cond: ref v350,
                                            } = &v345.1
                                            {
                                                if let &Opcode::Icmp = v348 {
                                                    let v354 = constructor_select(
                                                        ctx, v2.0, v106, v97.1, v97.2,
                                                    );
                                                    // Rule at src/opts/icmp.isle line 29.
                                                    returns.push(v354);
                                                    // Rule at src/opts/icmp.isle line 32.
                                                    returns.push(v354);
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v282,
                                    imm: v283,
                                } => {
                                    if let &Opcode::Iconst = v282 {
                                        let v284 = C::u64_from_imm64(ctx, v283);
                                        if v284 == 0x0 {
                                            // Rule at src/opts/cprop.isle line 169.
                                            returns.push(v97.2);
                                        }
                                        let v285 = C::u64_is_zero(ctx, v284);
                                        if v285 == false {
                                            // Rule at src/opts/cprop.isle line 166.
                                            returns.push(v97.1);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 4.
                            returns.push(v97.1);
                        }
                    }
                    &Opcode::Bitselect => {
                        let v413 = C::multi_lane(ctx, v2.0);
                        if let Some(v414) = v413 {
                            let v97 = C::unpack_value_array_3(ctx, v96);
                            let v101 = C::inst_data_etor(ctx, v97.0);
                            let mut v101 = v101;
                            while let Some(v102) = v101.next(ctx) {
                                if let &InstructionData::IntCompare {
                                    opcode: ref v403,
                                    args: ref v404,
                                    cond: ref v405,
                                } = &v102.1
                                {
                                    if let &Opcode::Icmp = v403 {
                                        match v405 {
                                            &IntCC::SignedGreaterThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 28.
                                                        returns.push(v409);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 42.
                                                        returns.push(v411);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 29.
                                                        returns.push(v409);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 43.
                                                        returns.push(v411);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 32.
                                                        returns.push(v411);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 38.
                                                        returns.push(v409);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v411 = constructor_smin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 33.
                                                        returns.push(v411);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v409 = constructor_smax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 39.
                                                        returns.push(v409);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 30.
                                                        returns.push(v410);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 44.
                                                        returns.push(v412);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 31.
                                                        returns.push(v410);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 45.
                                                        returns.push(v412);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 34.
                                                        returns.push(v412);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 40.
                                                        returns.push(v410);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v406 = C::unpack_value_array_2(ctx, v404);
                                                if v97.1 == v406.0 {
                                                    if v97.2 == v406.1 {
                                                        let v412 = constructor_umin(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 35.
                                                        returns.push(v412);
                                                    }
                                                }
                                                if v97.1 == v406.1 {
                                                    if v97.2 == v406.0 {
                                                        let v410 = constructor_umax(
                                                            ctx, v2.0, v406.0, v406.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 41.
                                                        returns.push(v410);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 5.
                            returns.push(v97.1);
                        }
                    }
                    &Opcode::Fma => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v105,
                                arg: v106,
                            } = &v102.1
                            {
                                if let &Opcode::Fneg = v105 {
                                    if v2.0 == v102.0 {
                                        let v107 = C::inst_data_etor(ctx, v97.1);
                                        let mut v107 = v107;
                                        while let Some(v108) = v107.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v111,
                                                arg: v112,
                                            } = &v108.1
                                            {
                                                if let &Opcode::Fneg = v111 {
                                                    if v2.0 == v108.0 {
                                                        let v113 = constructor_fma(
                                                            ctx, v2.0, v106, v112, v97.2,
                                                        );
                                                        // Rule at src/opts/arithmetic.isle line 122.
                                                        returns.push(v113);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v27,
                arg: v28,
            } => {
                match v27 {
                    &Opcode::Splat => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::UnaryIeee32 {
                                    opcode: ref v302,
                                    imm: v303,
                                } => {
                                    if let &Opcode::F32const = v302 {
                                        let v304 = C::u32_from_ieee32(ctx, v303);
                                        let v305 = C::u32_as_u64(ctx, v304);
                                        let v306 = constructor_splat32(ctx, v305);
                                        let v307 = constructor_vconst(ctx, v2.0, v306);
                                        // Rule at src/opts/cprop.isle line 185.
                                        returns.push(v307);
                                    }
                                }
                                &InstructionData::UnaryIeee64 {
                                    opcode: ref v308,
                                    imm: v309,
                                } => {
                                    if let &Opcode::F64const = v308 {
                                        let v310 = C::u64_from_ieee64(ctx, v309);
                                        let v311 = C::splat64(ctx, v310);
                                        let v312 = constructor_vconst(ctx, v2.0, v311);
                                        // Rule at src/opts/cprop.isle line 187.
                                        returns.push(v312);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        match v30.0 {
                                            I8 => {
                                                let v287 = C::u64_uextend_imm64(ctx, I8, v198);
                                                let v288 = constructor_splat8(ctx, v287);
                                                let v289 = constructor_vconst(ctx, v2.0, v288);
                                                // Rule at src/opts/cprop.isle line 177.
                                                returns.push(v289);
                                            }
                                            I16 => {
                                                let v291 = C::u64_uextend_imm64(ctx, I16, v198);
                                                let v292 = constructor_splat16(ctx, v291);
                                                let v293 = constructor_vconst(ctx, v2.0, v292);
                                                // Rule at src/opts/cprop.isle line 179.
                                                returns.push(v293);
                                            }
                                            I32 => {
                                                let v295 = C::u64_uextend_imm64(ctx, I32, v198);
                                                let v296 = constructor_splat32(ctx, v295);
                                                let v297 = constructor_vconst(ctx, v2.0, v296);
                                                // Rule at src/opts/cprop.isle line 181.
                                                returns.push(v297);
                                            }
                                            I64 => {
                                                let v299 = C::u64_uextend_imm64(ctx, I64, v198);
                                                let v300 = C::splat64(ctx, v299);
                                                let v301 = constructor_vconst(ctx, v2.0, v300);
                                                // Rule at src/opts/cprop.isle line 183.
                                                returns.push(v301);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Ineg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    if let &Opcode::Ushr = v57 {
                                        if v2.0 == v30.0 {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v62 = C::inst_data_etor(ctx, v59.1);
                                            let mut v62 = v62;
                                            while let Some(v63) = v62.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v66,
                                                    imm: v67,
                                                } = &v63.1
                                                {
                                                    if let &Opcode::Iconst = v66 {
                                                        let v68 = C::u64_from_imm64(ctx, v67);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v448 = C::u64_eq(ctx, v68, v153);
                                                        if v448 == true {
                                                            if v2.0 == v63.0 {
                                                                let v449 = constructor_sshr(
                                                                    ctx, v2.0, v59.0, v59.1,
                                                                );
                                                                // Rule at src/opts/shifts.isle line 102.
                                                                returns.push(v449);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Ineg = v33 {
                                        if v2.0 == v30.0 {
                                            let v35 = C::subsume(ctx, v34);
                                            // Rule at src/opts/arithmetic.isle line 25.
                                            returns.push(v35);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Iabs => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                match v33 {
                                    &Opcode::Ineg => {
                                        if v2.0 == v30.0 {
                                            let v42 = constructor_iabs(ctx, v2.0, v34);
                                            // Rule at src/opts/arithmetic.isle line 32.
                                            returns.push(v42);
                                        }
                                    }
                                    &Opcode::Iabs => {
                                        if v2.0 == v30.0 {
                                            let v43 = C::subsume(ctx, v28);
                                            // Rule at src/opts/arithmetic.isle line 36.
                                            returns.push(v43);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Bnot => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    match v57 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v70 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v67,
                                                            );
                                                            if v70 == -0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 82.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let v71 = C::inst_data_etor(ctx, v59.0);
                                                let mut v71 = v71;
                                                while let Some(v72) = v71.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v75,
                                                        imm: v76,
                                                    } = &v72.1
                                                    {
                                                        if let &Opcode::Iconst = v75 {
                                                            let v77 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v76,
                                                            );
                                                            if v77 == -0x1 {
                                                                if v2.0 == v72.0 {
                                                                    let v78 = constructor_ineg(
                                                                        ctx, v2.0, v59.1,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 85.
                                                                    returns.push(v78);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v68 = C::u64_from_imm64(ctx, v67);
                                                            if v68 == 0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 80.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Band => {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                            let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                            let v122 = constructor_bor(ctx, v2.0, v119, v120);
                                            // Rule at src/opts/bitops.isle line 60.
                                            returns.push(v122);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                                let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                                let v121 = constructor_band(ctx, v2.0, v119, v120);
                                                // Rule at src/opts/bitops.isle line 57.
                                                returns.push(v121);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Bnot = v33 {
                                        if v2.0 == v30.0 {
                                            let v35 = C::subsume(ctx, v34);
                                            // Rule at src/opts/bitops.isle line 53.
                                            returns.push(v35);
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v30.0 == v45 {
                                                let v199 = C::u64_from_imm64(ctx, v198);
                                                let v200 = C::u64_not(ctx, v199);
                                                let v201 = C::imm64_masked(ctx, v45, v200);
                                                let v202 = constructor_iconst(ctx, v45, v201);
                                                let v203 = C::subsume(ctx, v202);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v203);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v396 = C::remat(ctx, arg0);
                        // Rule at src/opts/remat.isle line 24.
                        returns.push(v396);
                    }
                    &Opcode::Fneg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Fneg = v33 {
                                    if v2.0 == v30.0 {
                                        let v35 = C::subsume(ctx, v34);
                                        // Rule at src/opts/arithmetic.isle line 118.
                                        returns.push(v35);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ireduce => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                match v33 {
                                    &Opcode::Uextend => {
                                        let v328 = C::value_type(ctx, v34);
                                        if v2.0 == v328 {
                                            // Rule at src/opts/extends.isle line 34.
                                            returns.push(v34);
                                        }
                                    }
                                    &Opcode::Sextend => {
                                        let v328 = C::value_type(ctx, v34);
                                        if v2.0 == v328 {
                                            // Rule at src/opts/extends.isle line 33.
                                            returns.push(v34);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Uextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Uextend = v33 {
                                        let v313 = constructor_uextend(ctx, v2.0, v34);
                                        // Rule at src/opts/extends.isle line 2.
                                        returns.push(v313);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v213 = C::u64_uextend_imm64(ctx, v30.0, v198);
                                            let v214 = C::imm64(ctx, v213);
                                            let v215 = constructor_iconst(ctx, v45, v214);
                                            let v216 = C::subsume(ctx, v215);
                                            // Rule at src/opts/cprop.isle line 73.
                                            returns.push(v216);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Sextend = v33 {
                                        let v314 = constructor_sextend(ctx, v2.0, v34);
                                        // Rule at src/opts/extends.isle line 4.
                                        returns.push(v314);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v217 = C::i64_sextend_imm64(ctx, v30.0, v198);
                                            let v218 = C::i64_as_u64(ctx, v217);
                                            let v219 = C::imm64_masked(ctx, v45, v218);
                                            let v220 = constructor_iconst(ctx, v45, v219);
                                            let v221 = C::subsume(ctx, v220);
                                            // Rule at src/opts/cprop.isle line 76.
                                            returns.push(v221);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v399,
                imm: v400,
            } => {
                if let &Opcode::F32const = v399 {
                    let v396 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 28.
                    returns.push(v396);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v401,
                imm: v402,
            } => {
                if let &Opcode::F64const = v401 {
                    let v396 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 30.
                    returns.push(v396);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v397,
                imm: v398,
            } => {
                if let &Opcode::Iconst = v397 {
                    let v396 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 26.
                    returns.push(v396);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term splat8.
pub fn constructor_splat8<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x8);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat16(ctx, v3);
    // Rule at src/opts/cprop.isle line 191.
    return v4;
}

// Generated as internal constructor for term splat16.
pub fn constructor_splat16<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x10);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat32(ctx, v3);
    // Rule at src/opts/cprop.isle line 193.
    return v4;
}

// Generated as internal constructor for term splat32.
pub fn constructor_splat32<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x20);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = C::splat64(ctx, v3);
    // Rule at src/opts/cprop.isle line 195.
    return v4;
}

// Generated as internal constructor for term intcc_comparable.
pub fn constructor_intcc_comparable<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &IntCC,
) -> Option<bool> {
    let v2 = constructor_intcc_class(ctx, arg0);
    let v3 = constructor_intcc_class(ctx, arg1);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::u64_is_zero(ctx, v4);
    if v5 == false {
        let v7 = C::u64_eq(ctx, 0x2, v4);
        // Rule at src/opts/icmp.isle line 137.
        return Some(v7);
    }
    None
}

// Generated as internal constructor for term decompose_intcc.
pub fn constructor_decompose_intcc<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 142.
            return 0x1;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 151.
            return 0x6;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 148.
            return 0x4;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 150.
            return 0x5;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 144.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 146.
            return 0x3;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 147.
            return 0x4;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 149.
            return 0x5;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 143.
            return 0x2;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 145.
            return 0x3;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "decompose_intcc", "src/opts/icmp.isle line 141"
    )
}

// Generated as internal constructor for term compose_icmp.
pub fn constructor_compose_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
    arg2: bool,
    arg3: Value,
    arg4: Value,
) -> Value {
    match arg1 {
        0x0 => {
            let v6 = C::imm64(ctx, 0x0);
            let v7 = constructor_iconst(ctx, arg0, v6);
            let v8 = C::subsume(ctx, v7);
            // Rule at src/opts/icmp.isle line 154.
            return v8;
        }
        0x1 => {
            let v10 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg3, arg4);
            // Rule at src/opts/icmp.isle line 155.
            return v10;
        }
        0x2 => {
            match arg2 {
                true => {
                    let v14 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 157.
                    return v14;
                }
                false => {
                    let v12 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 156.
                    return v12;
                }
                _ => {}
            }
        }
        0x3 => {
            match arg2 {
                true => {
                    let v18 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 159.
                    return v18;
                }
                false => {
                    let v16 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 158.
                    return v16;
                }
                _ => {}
            }
        }
        0x4 => {
            match arg2 {
                true => {
                    let v22 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 161.
                    return v22;
                }
                false => {
                    let v20 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 160.
                    return v20;
                }
                _ => {}
            }
        }
        0x5 => {
            match arg2 {
                true => {
                    let v26 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 163.
                    return v26;
                }
                false => {
                    let v24 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 162.
                    return v24;
                }
                _ => {}
            }
        }
        0x6 => {
            let v28 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg3, arg4);
            // Rule at src/opts/icmp.isle line 164.
            return v28;
        }
        0x7 => {
            let v30 = C::imm64(ctx, 0x1);
            let v31 = constructor_iconst(ctx, arg0, v30);
            let v32 = C::subsume(ctx, v31);
            // Rule at src/opts/icmp.isle line 165.
            return v32;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "compose_icmp", "src/opts/icmp.isle line 153"
    )
}

// Generated as internal constructor for term intcc_class.
pub fn constructor_intcc_class<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 176.
            return 0x3;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 177.
            return 0x3;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 174.
            return 0x2;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 175.
            return 0x2;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 172.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 173.
            return 0x2;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 170.
            return 0x1;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 171.
            return 0x1;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 168.
            return 0x1;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 169.
            return 0x1;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "intcc_class", "src/opts/icmp.isle line 167"
    )
}

// Generated as internal constructor for term shift_amt_to_type.
pub fn constructor_shift_amt_to_type<C: Context>(ctx: &mut C, arg0: u64) -> Option<Type> {
    match arg0 {
        0x8 => {
            // Rule at src/opts/shifts.isle line 97.
            return Some(I8);
        }
        0x10 => {
            // Rule at src/opts/shifts.isle line 98.
            return Some(I16);
        }
        0x20 => {
            // Rule at src/opts/shifts.isle line 99.
            return Some(I32);
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 364.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 373.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 382.
    return v6;
}

// Generated as internal constructor for term x86_pshufb.
pub fn constructor_x86_pshufb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pshufb,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 391.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 400.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 409.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 418.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 427.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 436.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 445.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 454.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 463.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 472.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 481.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 490.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 499.
    return v6;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 508.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 517.
    return v6;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 526.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 535.
    return v6;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 544.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 553.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 562.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 571.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 580.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 589.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 598.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 607.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 616.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 625.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 634.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 643.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 652.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 661.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 670.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 679.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 688.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 697.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 706.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 715.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 724.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 733.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 742.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 751.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 760.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 769.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 778.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 787.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 796.
    return v7;
}

// Generated as internal constructor for term x86_blendv.
pub fn constructor_x86_blendv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::X86Blendv,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 805.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 814.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 823.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 832.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 841.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 850.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 859.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 868.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 877.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 886.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 895.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 904.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 913.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 922.
    return v6;
}

// Generated as internal constructor for term x86_pmulhrsw.
pub fn constructor_x86_pmulhrsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmulhrsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 931.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 940.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 949.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 958.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 967.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 976.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 985.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 994.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1003.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1012.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1021.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1030.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1039.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1048.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1057.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1066.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1075.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1084.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1093.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1102.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1111.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1120.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1129.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1138.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1147.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1156.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1165.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1174.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1183.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1192.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1201.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1210.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1219.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1228.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1237.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1246.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1255.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1264.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1273.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1282.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1291.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1300.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1309.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1318.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1327.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1336.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1345.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1354.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1363.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1372.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1381.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1390.
    return v6;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FminPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1399.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1408.
    return v6;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FmaxPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1417.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1426.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1435.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1444.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1453.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1462.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1471.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1480.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1489.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1498.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1507.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1516.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1525.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1534.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1543.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1552.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1561.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1570.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1579.
    return v6;
}

// Generated as internal constructor for term x86_pmaddubsw.
pub fn constructor_x86_pmaddubsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmaddubsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1588.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1597.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1606.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1615.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1624.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1633.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1642.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1651.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1660.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1669.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1678.
    return v4;
}

// Generated as internal constructor for term x86_cvtt2dq.
pub fn constructor_x86_cvtt2dq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::X86Cvtt2dq,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1687.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1696.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1705.
    return v4;
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtLowFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1714.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1723.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1732.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1741.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1750.
    return v5;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/zwitterion/Documents/opensource/extism/target/debug/build/cranelift-codegen-451f066b96c71eaf/out/clif_opt.isle line 1759.
    return v5;
}
